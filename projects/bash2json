#!/bin/bash
#
# bash2json: The most bash-based JSON parser
# Credits: Tirito6626, 2025
# License: Apache License 2.0
#

(return 0 2>/dev/null) && export sourced=true || export sourced=false

function bash2json {
local ultraverbose=false
local orig_IFS="$IFS"
error() {
  exit=${2}
  echo "error: $1" >&2
  "${exit:=true}" && { ! "${sourced}" && exit 1 || return 1; }
}
json_trim() {
  local input="$1"
  inside_string=0
  result=""
  while IFS='' read -r -n 1 char; do
    if [[ "$prevchar" == '\' ]]; then
      result+="$char"; prevchar="$char"; continue
    else 
      [[ "$char" == '"' ]] && ((inside_string ^= 1))
    fi
    [[ "$inside_string" = 0 && "$char" == " " ]] && continue
    result+="$char"
    prevchar="$char"
  done <<< "$input"
  echo "$result"
}
json_append() {
  local input="$(json_trim "$1")"
  local key="$2"
  local value="$3"
  if [[ "$key" =~ \. ]]; then 
    IFS=' ' read key subkey <<< "${key/./ }"
    local keyout=$(json_query "$input" "$key")
    [[ "$keyout" == null ]] && input=$($FUNCNAME "$input" "$key" '{}') && keyout='{}'
    local newkeyout=$($FUNCNAME "$keyout" "$subkey" "$value")
    [[ "$key" =~ \[[0-9]*\] ]] && local keyout=$(json_query "$input" "${key//\[[0-9]\]/}")
    keyout="${keyout//\[/\\[}"
    newkeyout="${newkeyout//\[/\\[}"
    key="${key//\[[0-9]\]/}"
    input="${input/\"${key}\":${keyout}/\"${key}\":${newkeyout}}"
    echo "${input//\\[/[}"
  elif [[ "$key" =~ "[]" ]]; then 
    case "$value" in 
          true|false|[0-9]|null) : ;;
          *) 
            case "${value:0:1}" in 
              '"'|'{'|'[') : ;;
              *) value='"'"$value"'"' ;; 
            esac
    esac
    key="${key//\[\]/}"
    local keyout=$(json_query "$input" "${key}")
    local newkeyout=$($FUNCNAME "$keyout" "$value")
    keyout="\"${key}\":${keyout//\]/\\]}"
    newkeyout="\"${key}\":${newkeyout//\]/\]}"
    echo -e "${input/${keyout}/${newkeyout}}"
  else
    if [[ "${input:0:1}" == "{" ]]; then 
      [ -z "$key" ] && error "key missing"
      [ -z "$value" ] && error "value missing"
      case "$value" in 
          true|false|[0-9]|null) : ;;
          *) 
            case "${value:0:1}" in 
              '"'|'{'|'[') : ;;
              *) value='"'"$value"'"' ;; 
            esac
      esac
      if [[ "$key" =~ '=' ]]; then 
        IFS='=' read key type <<< "$key"
        [[ "$type" == "string" && "${value:0:1}" != '"' ]] && value="\"$value\""
      fi
      key="${key//\"}"
      key="${key//\[[0-9]\]/}"

      local keyout=$(json_query "$input" "$key")
      if [[ "$keyout" != "null" ]]; then 
        echo "${input/\"${key}\":${keyout}/\"${key}\":${value}}"
      else 
        [[ "$input" = '{}' ]] && echo "{\"${key}\":$value}" || echo "${input/%\}/,\"${key}\":$value}}" 
      fi
    elif [[ "${input:0:1}" == "[" ]]; then
      [ -z "$key" ] && error "key missing"
      [ -z "$value" ] && value="$key" || value='{ "'"$key"'": '"$value"' }'
      case "$value" in 
          true|false|[0-9]|null) : ;;
          *) 
            case "${value:0:1}" in 
              '"'|'{'|'[') : ;;
              *) value="\"$value\"" ;; 
            esac
      esac
      if [[ "$input" == '[]' ]]; then
        echo "[$value]"
      else
      echo "${input/%]/,$value]}"
      fi
    else 
      error "can't append JSON: not a valid key type" 
    fi
 fi 
}
json_list() {
local input="$1"
if [[ "${input:0:1}" = '{' ]]; then
  local depth=0
  local result=''
  local prevchar=''
  inside_string=0
    while IFS='' read -r -d '' -n 1 char; do
      [[ "$prevchar" == '\' ]] && result+="$char" && prevchar="$char" && continue
      if (( $depth == 1 )); then
        [[ "$char" == '"' && "$prevchar" != '\' ]] && { ((inside_string ^= 1)); continue; }
        [[ "$char" = ":" && $inside_string = 0 ]] && result+=" " && continue
        [[ "$char" == "," && "$inside_string" = 0 ]] && result+="\n" && continue
      fi
      [[ "$char" == "{" ]] && ((++depth))
      [[ "$char" == "}" ]] && ((--depth))
      [[ "$char" == '[' ]] && ((++depth))
      [[ "$char" == "]" ]] && ((--depth))
      ((depth == 0)) && break || result+="$char"
  done < <(printf %s "$input")
  echo -e "${result:1}"
elif [[ "${input:0:1}" = '[' ]]; then
  local depth=0
  local result=''
  local prevchar=''
  inside_string=0
    while IFS='' read -r -d '' -n 1 char; do
      [[ "$prevchar" == '\' ]] && result+="$char" && prevchar="$char" && continue
      [[ "$char" == '"' && "$prevchar" != '\' ]] && ((inside_string ^= 1))
      [[ "$char" == "," && (( "$inside_string" = 0 )) ]] && ((depth == 1)) && result+="\n" && continue
      [[ "$char" == "{" ]] && ((++depth))
      [[ "$char" == "}" ]] && ((--depth))
      [[ "$char" == '[' ]] && ((++depth))
      [[ "$char" == "]" ]] && ((--depth))
      ((depth == 0)) && break || result+="$char"
  done < <(printf %s "$input")
  echo -e "${result:1}"
else 
  echo "$input"
fi
}

json_validate() {
  local input="$1"
   trimmed_json=$(json_trim "$input")
  depth=0
  newstring=''
     depth=0
  dquotes=0
  bdepth=0
  type=null
  newstring=''
  firstchar=''
  quoted=true
  prevchar=''
  unquotedchars=''
  while IFS='' read -r -d '' -n 1 char; do
    [[ "$prevchar" == '\' ]] && newstring+="$char" && prevchar="$char" && continue
    [[ "$prevchar" == '{' || "$prevchar" == ':' || "$prevchar" == ',' ]]  && [[ "$char" != '"' && "$char" != 't' && "$char" != 'f' && "$char" != [0-9] && "$char" != '}' && "$char" != '{'  && "$char" != '[' && "$char" != ']' && "$char" != ',' ]] && quoted=false && unquotedchars+="$char" && continue
    if ! "$quoted"; then 
      [[ "$char" != '}' && "$char" != ']' && "$char" != ':' && "$char" != ',' ]] && unquotedchars+="$char" || { unquotedchars+=" "; quoted=true; } 
    fi
    [[ "$prevchar" == ',' && "$char" == ',' ]] && error "unexpected ',,'"
    if [ -z "$firstchar" ]; then 
      firstchar="$char"
      case "$char" in 
        '{') type='object'  ;;
        '[') type='array'   ;;
        '"') type='string'  ;;
        t|f) type='boolean' ;;
        [0-9]) type='int'   ;;
        *)     type=null    ;; 
      esac
      newstring+="$char"
      ((++depth))
      continue 
    fi
    if [[ "$firstchar" == "{" ]]; then 
      newstring+="$char"
      [[ "$char" == '{' ]] && ((++depth))
      [[ "$char" == '}' ]] && ((--depth))
      [[ "$char" == '"' ]] && ((++dquotes))
      [[ "$char" == '[' ]] && ((++bdepth))
      [[ "$char" == ']' ]] && ((--bdepth))
    elif [[ "$firstchar" == "[" ]]; then 
      [[ "$depth" -gt 1 && "$char" == "," ]] && newstring+=" " || newstring+="$char"
      [[ "$char" == '[' ]] && ((++depth))
      [[ "$char" == "]" ]] && ((--depth))
      [[ "$char" == '"' ]] && ((++dquotes))
    elif [[ "$firstchar" == '"' ]]; then
      [[ "$char" == '"' ]] && ((--depth)) || newstring+="$char"
    else 
      newstring+="$char"
      [[ "$char" == ',' ||  "$char" == '}' ]] && newstring=${newstring::-1} && break 
    fi
    prevchar="$char"
  done < <(printf %s "$trimmed_json")
 # set -x
}

json_query() {
  local input="$1"
  local key="$2"
  local sub=false
  local raw="$3"
    while read key; do
   if [[ "$key" =~ \. ]]; then 
    sub=true
    IFS=' ' read key subkey <<<"${key/\./ }"
    if [ -z "$subkey" ]; then 
      ! "$silent" && error "invalid key invocation: \`$2'; expected <key>.<subkey>"
    fi 
    input=$($FUNCNAME "$input" "$key")
    key="$subkey"
  fi
    if [[ "$key" =~ \[[0-9]*\] ]]; then 
    [[ "${BASH_REMATCH[0]:1:-1}" != "" ]] || error "expected index number"
    keyout=$($FUNCNAME "$input" "${key//\[[0-9]*\]}")
    [[ "${keyout:0:1}" != '[' ]] && error "cannot get index of non-array"
    local arr=($(json_list "$keyout"))
    output="${arr[${BASH_REMATCH[0]:1:-1}]}"
    [ ! -z "$output" ] && echo "$("${raw:=false}" && echo "${output//\"}" || echo "$output")" || echo null
    exit 0
    fi
  trimmed_json=$(json_trim "$input")
  if [ ! -z "$key" ]; then 
  [[ "$trimmed_json"  =~ \"$key\":(.*) ]] && string="${BASH_REMATCH[1]}" || { echo null; exit; }
  depth=0
  type=null
  newstring=''
  firstchar=''
  while IFS='' read -r -d '' -n 1 char; do
    [ -z "$firstchar" ] && firstchar="$char"
    if [[ "$firstchar" == "{" ]]; then 
      newstring+="$char"
      [[ "$char" == "{" ]] && ((++depth))
      [[ "$char" == "}" ]] && ((--depth))
      ((depth == 0)) && break || continue 
    elif [[ "$firstchar" == "[" ]]; then 
      newstring+="$char"
      [[ "$char" == '[' ]] && ((++depth))
      [[ "$char" == "]" ]] && ((--depth))
      ((depth == 0)) && break || continue 
    elif [[ "$firstchar" == '"' ]]; then
      [[ "$char" == '"' && "$prevchar" != '\' ]] && ((--depth))
      ((depth == 0)) && break || newstring+="$char" 
    else 
      newstring+="$char"
      [[ "$char" == ',' ||  "$char" == '}' ]] && newstring=${newstring::-1} && break 
    fi
  done < <(printf %s "$string")
  if [[ "${firstchar}" == '"' ]]; then 
    [[ "${newstring: -1}"  == '}' ]] && newstring="${newstring::-1}"
    "${raw:=false}" && echo -e "${newstring//\"}" || echo -e "${newstring}"
  else 
    echo -e "${newstring}"
  fi
else 
  echo "$trimmed_json"
fi
done <<< "${key//,/\\n}"
}

arr_to_json() {
  i=0
  local input="$1"
  while IFS=$'\n' read -r arrkey; do
    ((i++))
    ((i > 1)) && data='[]'
    local typeofvar="$(declare -p "$arrkey" 2>/dev/null)"
    if [[ "$typeofvar" =~ "declare -A" ]]; then 
      local data='{}'
      declare -n bash2json_input_arr="$arrkey"
      keys="${!bash2json_input_arr[@]}"
      while read -r key; do
        local value="${bash2json_input_arr[$key]}"
        local typeofvar="$(declare -p "$value" 2>/dev/null)"
        if [ ! -z "${value}" ] && [[ "$typeofvar" =~ "declare -A" || "$typeofvar" =~ "declare -a" ]]; then 
          local value=$($FUNCNAME "$value" $vars)
        fi
        data=$(json_append "$data" "$key" "$value")
      done <<< "${keys// /$'\n'}"
      data=${data#\],}
      data=${data/,,/,}
    elif [[ "$typeofvar" =~ "declare -a" ]]; then
      local data='[]'
      declare -n bash2json_input_arr="$arrkey"
      local keys="${bash2json_input_arr[@]}"
      while read -r key; do
        [[ "$(declare -p "$key" 2>/dev/null)" =~ "declare -A" ]] && local key=$($FUNCNAME "$key")
        data=$(json_append "$data" "$key")
      done <<< "${keys// /$'\n'}"
      data=${data#\],}
      data=${data/,,/,}
    fi
  done <<< "${input/ /$'\n'}"
  echo "$data" 
}

json_to_arr() {
    local json=$(json_trim "$1")
    local evalline=""
    [ -z "$2" ] && local output_arr=array_$RANDOM || local output_arr="$2"
    if [[ "${json:0:1}" == '{' ]]; then 
      [ -z "$3" ] && evalline+="declare -Ag $output_arr=(" || local parentkey="$3."
      while read line; do 
        IFS=' ' read key value <<< "$line"
        if [[ ${value:0:1} == "{" ]]; then 
          while read subline; do 
            evalline+="$subline"
          done <<< "$($FUNCNAME "$value" "" "${parentkey}$key")"
        else 
          [ -z "$3" ] && evalline+="[$key]=\"$value\" " || evalline+="[${parentkey}$key]=\"$value\" "
      fi
      done <<< "$(json_list "$json")"
    elif [[ "${json:0:1}" == '[' ]]; then
      [ -z "$3" ] && evalline+="declare -ag $output_arr=("
      while read key; do
        key="${key#\"}"
        evalline+="'${key%\"}' "
      done <<< "$(json_list "$json")"
    fi
    [ -z "$3" ] && evalline+=')'
    echo "$evalline"
}
local vers='v2.2.0'
local silent=false
local validate=true
declare -a args=()
for arg in "$@"; do
case $arg in
-V|--version)
echo "bash2json [${vers}]"
echo "Copyright (C) 2025 Tirito6626"
exit
;;
-uv)           local ultraverbose=true    ;;
--from-json)   local action=from_json     ;;
--to-json)     local action=to_json       ;;
-q|--query)    local action=query         ;;
-T|--trim)     local action=trim          ;;
-A|--append)   local action=append        ;;
-H|-h|--help)  local action=help          ;;  
-v|--validate) local action=validate      ;;
-N|--no-validate) local validate=false    ;;
-s|--silent)   local silent=true          ;;
--auto-detect) local autodetect=true      ;;
--stdin)       local readfromstdin=true   ;;
-r|--raw)      local rawout=true          ;;
--input=*)   local input="${arg#*=}"      ;;
--output=*)  local output_arr="${arg#*=}" ;;
--mode=*)    local mode="${arg#*=}"       ;;
--auto-detect=*) local autodetect="${arg#*=}" ;;
*)              local allargs+=("$arg") ;;
esac
done
"$ultraverbose" && set -x
if [[ "$action" != "help" && "$action" != "to_json" && "${allargs[0]:0:1}" != '{' && "${allargs[0]:0:1}" != '[' ]]; then
if "${readfromstdin:=false}"; then 
  local var="$(</dev/stdin)"
  local query=${allargs[0]}
  local arg2=${allargs[1]}
  local arg3=${allargs[2]}
else 
  if [ -f "$input" ] || [ -L "$input" ]; then 
    local var="$(<"$input")"
    local query=${allargs[0]}
    local arg2=${allargs[1]}
    local arg3=${allargs[2]}
  elif [[ "${input:0:1}" = '{' ||  "${input:0:1}" = '[' ]]; then 
    local var="$input"
    local query=${allargs[0]}
    local arg2=${allargs[1]}
    local arg3=${allargs[2]}
  else
    local var=${allargs[0]}
    local query=${allargs[1]}
    local arg2=${allargs[2]}
    local arg3=${allargs[3]}
  fi
fi
else 
    local var=${allargs[0]}
    local query=${allargs[1]}
    local arg2=${allargs[2]}
    local arg3=${allargs[3]}
fi
"${validate}" && [[ "${action:=query}" != "validate" && "${action:=query}" != "to_json"  && "${action:=query}" != "help" ]] && json_validate "$var"
[[ "$action" != "help" ]] && [ -z "$var" ] && error "input missing"
case "${action:=query}" in
help)
cat <<-EOF
Usage: $(! "$sourced" && echo "${0}" || echo "$FUNCNAME") <input> <query|key?> <value?> [options?]

Available options:
--from-json <input> <name?>         Convert JSON into associative/indexed array
--to-json   <array>                 Convert associative/indexed array into JSON
-q|--query  <input> <key>           Perform a JSON query (e.g. 'key' or 'key.subkey' or '[0].key') (default)
-A|--append <input> <key> <value>   Append key to JSON
-T|--trim   <input>                 Trim JSON (remove all spaces outside of double quotes)
-H|-h|--help                        Return this message
-V|--version                        Show current version
-v|--validate <input>               Validate JSON
-N|--no-validate                    Don't validate JSON input before actions
-s|--silent                         Don't return errors
--auto-detect                       Auto-detect key types while using --to-json
--stdin                             Read from standart input
-r|--raw                            Raw output
--input=<file/JSON>                 Set input or file to use as input 
--output=<name>                     Set output array name (doesn't execute it)
--auto-detect=<bool>                Enable/disable auto-detection


--from-json generates single array command with all keys and subkeys
Subkeys are returned as "declare -Ag <array name>=( ... [<key>.<subkey>]=<subkey value> )"

$(! "$sourced" && echo "NOTE: --to-json requires bash2json to be sourced, otherwise bash2json wouldn't be able access arrays")
EOF
;;
validate)  json_validate "$var" ;;
append)    json_append "$var" "$query" "$arg2" ;;
query)     json_query "$var" "$query" "${rawout:=false}" ;;
from_json) json_to_arr "$var" "${output_arr:-${query}}" ;;
trim)      json_trim "$var" ;;
to_json)   arr_to_json "$var" ;;
esac
"$ultraverbose" && set +x
IFS="$old_IFS"
}
! "$sourced" && bash2json "$@"
